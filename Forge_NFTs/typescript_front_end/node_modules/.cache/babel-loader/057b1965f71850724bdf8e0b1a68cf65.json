{"ast":null,"code":"import _regeneratorRuntime from \"/home/forgeserver/Desktop/MainNet-Forge-NFT/defi-stake-yield-brownie-main/front_end/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/home/forgeserver/Desktop/MainNet-Forge-NFT/defi-stake-yield-brownie-main/front_end/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/home/forgeserver/Desktop/MainNet-Forge-NFT/defi-stake-yield-brownie-main/front_end/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/home/forgeserver/Desktop/MainNet-Forge-NFT/defi-stake-yield-brownie-main/front_end/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { usePromiseTransaction } from './usePromiseTransaction';\nexport function connectContractToSigner(contract, options, library) {\n  if (contract.signer) {\n    return contract;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.signer) {\n    return contract.connect(options.signer);\n  }\n\n  if (library === null || library === void 0 ? void 0 : library.getSigner()) {\n    return contract.connect(library.getSigner());\n  }\n\n  throw new TypeError('No signer available in contract, options or library');\n}\nexport function useContractFunction(contract, functionName, options) {\n  var _useEthers = useEthers(),\n      library = _useEthers.library,\n      chainId = _useEthers.chainId;\n\n  var _usePromiseTransactio = usePromiseTransaction(chainId, options),\n      promiseTransaction = _usePromiseTransactio.promiseTransaction,\n      state = _usePromiseTransactio.state;\n\n  var _useState = useState(undefined),\n      _useState2 = _slicedToArray(_useState, 2),\n      events = _useState2[0],\n      setEvents = _useState2[1];\n\n  var send = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var contractWithSigner,\n        receipt,\n        _events,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            contractWithSigner = connectContractToSigner(contract, options, library);\n            _context.next = 3;\n            return promiseTransaction(contractWithSigner[functionName].apply(contractWithSigner, _args));\n\n          case 3:\n            receipt = _context.sent;\n\n            if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n              _events = receipt.logs.reduce(function (accumulatedLogs, log) {\n                try {\n                  return log.address === contract.address ? [].concat(_toConsumableArray(accumulatedLogs), [contract.interface.parseLog(log)]) : accumulatedLogs;\n                } catch (_err) {\n                  return accumulatedLogs;\n                }\n              }, []);\n              setEvents(_events);\n            }\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), [contract, functionName, options, library]);\n  return {\n    send: send,\n    state: state,\n    events: events\n  };\n}","map":{"version":3,"sources":["../../../../src/hooks/useContractFunction.ts"],"names":[],"mappings":";;;;AAGA,SAAS,WAAT,EAAsB,QAAtB,QAAsC,OAAtC;AACA,SAAS,SAAT,QAA0B,aAA1B;AACA,SAAS,qBAAT,QAAsC,yBAAtC;AAGA,OAAM,SAAU,uBAAV,CAAkC,QAAlC,EAAsD,OAAtD,EAAoF,OAApF,EAA0G;AAC9G,MAAI,QAAQ,CAAC,MAAb,EAAqB;AACnB,WAAO,QAAP;AACD;;AAED,MAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,MAAb,EAAqB;AACnB,WAAO,QAAQ,CAAC,OAAT,CAAiB,OAAO,CAAC,MAAzB,CAAP;AACD;;AAED,MAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,SAAT,EAAJ,EAA0B;AACxB,WAAO,QAAQ,CAAC,OAAT,CAAiB,OAAO,CAAC,SAAR,EAAjB,CAAP;AACD;;AAED,QAAM,IAAI,SAAJ,CAAc,qDAAd,CAAN;AACD;AAED,OAAM,SAAU,mBAAV,CAA8B,QAA9B,EAAkD,YAAlD,EAAwE,OAAxE,EAAoG;AACxG,mBAA6B,SAAS,EAAtC;AAAA,MAAQ,OAAR,cAAQ,OAAR;AAAA,MAAiB,OAAjB,cAAiB,OAAjB;;AACA,8BAAsC,qBAAqB,CAAC,OAAD,EAAU,OAAV,CAA3D;AAAA,MAAQ,kBAAR,yBAAQ,kBAAR;AAAA,MAA4B,KAA5B,yBAA4B,KAA5B;;AACA,kBAA4B,QAAQ,CAA+B,SAA/B,CAApC;AAAA;AAAA,MAAO,MAAP;AAAA,MAAe,SAAf;;AAEA,MAAM,IAAI,GAAG,WAAW,wEACtB;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACQ,YAAA,kBADR,GAC6B,uBAAuB,CAAC,QAAD,EAAW,OAAX,EAAoB,OAApB,CADpD;AAAA;AAAA,mBAEwB,kBAAkB,CAAC,kBAAkB,CAAC,YAAD,CAAlB,OAAA,kBAAkB,QAAnB,CAF1C;;AAAA;AAEQ,YAAA,OAFR;;AAGE,gBAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,IAAb,EAAmB;AACX,cAAA,OADW,GACF,OAAO,CAAC,IAAR,CAAa,MAAb,CAAoB,UAAC,eAAD,EAAkB,GAAlB,EAAyB;AAC1D,oBAAI;AACF,yBAAO,GAAG,CAAC,OAAJ,KAAgB,QAAQ,CAAC,OAAzB,gCACC,eADD,IACkB,QAAQ,CAAC,SAAT,CAAmB,QAAnB,CAA4B,GAA5B,CADlB,KAEH,eAFJ;AAGD,iBAJD,CAIE,OAAO,IAAP,EAAa;AACb,yBAAO,eAAP;AACD;AACF,eARc,EAQZ,EARY,CADE;AAUjB,cAAA,SAAS,CAAC,OAAD,CAAT;AACD;;AAdH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GADsB,IAiBtB,CAAC,QAAD,EAAW,YAAX,EAAyB,OAAzB,EAAkC,OAAlC,CAjBsB,CAAxB;AAoBA,SAAO;AAAE,IAAA,IAAI,EAAJ,IAAF;AAAQ,IAAA,KAAK,EAAL,KAAR;AAAe,IAAA,MAAM,EAAN;AAAf,GAAP;AACD","sourceRoot":"","sourcesContent":["import { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { usePromiseTransaction } from './usePromiseTransaction';\nexport function connectContractToSigner(contract, options, library) {\n    if (contract.signer) {\n        return contract;\n    }\n    if (options === null || options === void 0 ? void 0 : options.signer) {\n        return contract.connect(options.signer);\n    }\n    if (library === null || library === void 0 ? void 0 : library.getSigner()) {\n        return contract.connect(library.getSigner());\n    }\n    throw new TypeError('No signer available in contract, options or library');\n}\nexport function useContractFunction(contract, functionName, options) {\n    const { library, chainId } = useEthers();\n    const { promiseTransaction, state } = usePromiseTransaction(chainId, options);\n    const [events, setEvents] = useState(undefined);\n    const send = useCallback(async (...args) => {\n        const contractWithSigner = connectContractToSigner(contract, options, library);\n        const receipt = await promiseTransaction(contractWithSigner[functionName](...args));\n        if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n            const events = receipt.logs.reduce((accumulatedLogs, log) => {\n                try {\n                    return log.address === contract.address\n                        ? [...accumulatedLogs, contract.interface.parseLog(log)]\n                        : accumulatedLogs;\n                }\n                catch (_err) {\n                    return accumulatedLogs;\n                }\n            }, []);\n            setEvents(events);\n        }\n    }, [contract, functionName, options, library]);\n    return { send, state, events };\n}\n//# sourceMappingURL=useContractFunction.js.map"]},"metadata":{},"sourceType":"module"}